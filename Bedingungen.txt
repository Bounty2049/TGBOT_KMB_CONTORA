Система счисления - это способ представления чисел с использованием цифр и правил их комбинирования для обозначения числовых величин.
Число - последовательность цифр и знаков.
Цифра - система знаков для записи чисел (элементарная единица, из которой состоит число)
Позиционная система счисления - система счисления, в которой значение цифры зависит от ее положения в числе.
Непозиционная система счисления - система счисления, в которой значение цифры не зависит от ее положения в числе.
Базис системы счисления - последовательность чисел, каждая из которых задает “вес” каждого разряда.
Основание системы счисления - количество символов в ее алфавите.
Алфавит системы счисления - набор символов, используемый для записи в данной системе счисления.
Смешанная система счисления - система счисления, в которой используются различные основания для разрядов.
P-Q-ичная система счисления - способ записи чисел, при котором числа из позиционной системы счисления с основанием Q записываются с помощью цифр системы счисления с основанием P (Смешанная СС)
Алгоритм - система точных и полных предписаний о характере и последовательности действий, которые необходимо выполнить, для решения поставленной задачи.
Массовость алгоритма - алгоритм должен быть применим для всех данных определенного класса.
Дискретность алгоритма - любой алгоритм представляет собой последовательность шагов. Каждый следующий шаг может быть выполнен тогда, когда завершен предыдущий.
Результативность алгоритма - исполнение алгоритма должно приводить к какому-либо результату за конечное число шагов для всех допустимых значений (свойство алгоритма).
Понятность алгоритма - любой алгоритм пишется и состоит из команд, предназначенных для конкретного исполнителя (исполнитель должен быть в состоянии выполнить этот алгоритм).
Точность алгоритма - всякая команда должна быть сформулирована так, чтобы однозначно определить действия исполнителя.
Конечность алгоритма - алгоритм должен всегда заканчиваться после выполнения конечного числа шагов (свойство алгоритма).
Определенность алгоритма - действия, которые необходимо выполнить на каждом шаге, должны быть строго и недвусмысленно сформулированы в каждом возможном случае.
Эффективность алгоритма - все операции алгоритма должны быть достаточно просты и выполнимы за допустимое конечное время.
Детерминированность алгоритма - при одних и тех же входных данных алгоритм будет выдавать один и тот же результат даже при внешних воздействиях.
Блок-схема - графическое представление алгоритма в виде последовательности связанных между собой функциональных блоков, каждый из которых соответствует выполнению одного или нескольких действий.
Действие - нечто, что имеет определенную продолжительность и приводит к получению определенного результата.
Псевдокод - запись алгоритма, который представляет собой сочетание естественного языка и ЯП.
Структурное программирование - методология разработки программного обеспечения, в основе которой лежит представление программы в виде иерархических блоков.
Язык программирования - формальный язык для записи алгоритмов с помощью ЭВМ. 
Программа - алгоритм, который записывается на языке программирования.
Исполнитель алгоритма - некоторая абстрактная или реальная (техническая, биологическая или биотехническая) система, способная выполнить действия, заданные алгоритмом.
Система команд исполнителя - список команд, которые может выполнить исполнитель. 
Команда исполнителя - команда, используемая исполнителем алгоритма.
Универсальный исполнитель алгоритмов - исполнитель, который может моделировать работу любого другого исполнителя.
Математическая модель задачи - задача, описанная при помощи математических формул.
Декомпозиция - разбиение исходной задачи на несколько более мелких подзадач, решение этих подзачад и возврат к решению исходной задачи.
Итерация - способ получения решения, когда повторяется одна и та же последовательность шагов начиная с одного или нескольких заранее заданных значений.
Эвристика - метод, когда пытаются воспроизвести логику человека при решении задачи.
Трансляция - перевод программы с языка программирования на объектный код. 
Объектный код - машинный код конкретного компьютера, не настроенный на среду выполнения. Нет стартового адреса для выполнения программы.
Компилятор - создает объектный код программы.
Интерпретатор - объектный код не создает, он выполняет программу построчно.
Сборка программы - устанавливаются связи между программой пользователя и программами, которые использует ОС.
Загрузочный файл - файл, содержащий информацию для загрузки программы
Интегрированная среда программирования - система программных средств, используемая программистами для разработки программного обеспечения.
Рекуррентная формула - формула, которая связывает между собой n+1 соседних членов последовательности.
Порядок рекуррентной формулы - это количество предыдущих членов последовательности, от которых зависит вычисление каждого следующего члена.
Линейная однородная рекуррентная формула - a1=a2=ai=1
Нелинейная рекуррентная формула - ai=ai-1 + cos(ai-2)
Линейная неоднородная рекуррентная формула - ai=ai-1+3
Линейная рекуррентная формула с переменными коэффициентами - ai=i*ai-1
Рекурсия - метод решения задачи, которая решается с помощью этой же задачи, но пониженной сложности.
Прямая рекурсия - когда функция вызывает саму себя
Косвенная рекурсия - циклическая последовательность вызовов нескольких функций: F1 вызывает FF2 вызывает F..., Fk вызывает F1 (k>1).
Рекурсивный стек - область данных, в которую заносятся значения всех локальных переменных алгоритма в момент рекурсивного обращения. Каждое такое обращение -один слой данных стека.
Прямой ход рекурсии - выполнение рекурсивного алгоритма до момента попадания на не рекурсивную ветвь.
Обратный ход рекурсии - процесс выполнения рекурсивного алгоритма после момента попадания на не рекурсивную ветвь.
Тип данных - определяет множество значений, к которым относится константа и которые может принимать переменная, выражение или функция.
Базовый тип данных - предопределен стандартом языка, указывается зарезервированными ключевыми словами и характеризуется одним значением.
Составной тип данных - состоит из комбинации значений базовых типов данных.
Скалярный тип данных - тип данных в С++ относящийся к указателям или арифметическим типам данных.
Мощность типа данных - количество различных значений, входящих в тип данных.
Иерархия типов данных - более сложные компоненты составляются из более простых, ранее определенных.
Стандартный тип данных - тип данных, объекты внутренней структуры которого не доступны программисту. В некоторый момент времени хранит только одно значение.
Сложный тип данных - тип данных, объекты внутренней структуры которого доступны программисту. В некоторый момент времени может хранить больше одного значения. 
Диаграмма Вирта - графический способ описания синтаксиса языка.
Форма Бэкуса-Наура - текстовый способ описания синтаксиса языка.
Терминальный символ - символ, не требующий обязательной расшифровки.
Нетерминальный символ - символ, требующий обязательной расшифровки.
Тип перечисление - тип данных, множество значений которого представляет собой ограниченный список идентификаторов.
Ограниченный тип - интервал значений базового типа. Описание типа задает наименьшее и наибольшее значения, входящие в этот интервал.
Тип множество - сложный тип данных, позволяющий хранить ограниченное количество значений определенного типа без определенного порядка.
Конструктор множества - перечисление элементов множества или отрезков базового типа, заключенного в квадратные скобки, через запятую.
Массив - набор из нескольких элементов, которые имеют простой тип данных.
Регулярный тип - структурный тип данных, представляющий собой совокупность пронумерованных однотипных величин.
Запись - структурированный тип, содержащий набор объектов разных типов.
Комбинированный тип - структурированный тип, состоящий из фиксированного числа полей разного типа.
Селектор записи - конструкция для выбора отдельного поля записи.
Файл - это данные на ЗУ компьютера, у которых есть имя и возможность чтения/записи.
Схема перебора элементов массива - один из способов просматривания элементов массива: линейно или нелинейно.
Линейная схема перебора элементов массива - индекс просматриваемого элемента в массиве изменяется линейно.
Нелинейная схема перебора элементов массива - индекс просматриваемого элемента в массиве изменяется нелинейно.
Класс задач на массивах № 1 - однотипная обработка всех или выбранных элементов массива.
Класс задач на массивах № 2 - изменение порядка или структуры элементов массива.
Класс задач на массивах № 3 - обработка нескольких массивов или подмассивов одного массива одновременно.
Класс задач на массивах № 4 - обработка массива с целью обнаружения элемента, равного заданному “аргументу поиска”.
Синхронная обработка элементов массива - КЗМ №3 + индекс первого массива или подмассива можно вычислить с помощью применения формулы к индексу второго массива или подмассива.
Асинхронная обработка элементов массива - КЗМ №3 + не существует формулы, которая связывает индексы разных обрабатываемых массивов или подмассивов.
Барьерный элемент массива - элемент относительно которого ведется сортировка (обычно справа и слева от него сравниваются элементы).
Сортировка - процесс упорядочивания элементов набора данных по заданному правилу, обычно по возрастанию или убыванию значений ключа.
Ключ элемента - составная часть элемента, по которой производится работа f(x,y).
Внутренняя сортировка - сортировка данных, для которой достаточно оперативной памяти.
Внешняя сортировка - сортировка данных, расположенных на внешнем устройстве (сортировка Фон Неймана - трехленточная).
Линейные сортировки - элементы рассматриваются всегда последовательно (нет основной структуры в порядке рассмотрения элементов).
Нелинейные сортировки - существует специальная функция, по которой выбираются элементы.
Простые сортировки - используется всегда один и тот же метод на протяжении всей сортировки.
Комбинированные сортировки - используется переключение метода сортировки в зависимости от какого-либо события.
Сравнительные сортировки - упорядочение производится по значению ключа элемента (значение ключа берется как единое целое, т.е. значение какого-либо элемента).
Распределительные сортировки - ключ рассматривается по своим составляющим, упорядочение происходит на их основе.
Сортировка с обособленным ключом - создается дополнительный массив, в котором записывается ключ записи и ее расположение в исходном массиве (индекс). Сортируется только массив ключей.
Сортировка с необособленным ключом - ключевая и информационная часть массива связаны и сортируются вместе.
Хеширование - способ упорядочивания информации в форму, удобную для реализации поиска. Сортировка без сравнения.
Хеш-функция - определяет место элемента в упорядоченной последовательности в процессе хеширования.
Рехеширование - повторное проведение хеширования, чтобы избавиться от коллизии.
Линейное рехеширование - попытка поместить объект в следующую строку хэш-таблицы. Если строка занята, то в следующую и так до свободной. Формула: hi(a)=(h0(a)+i)mod n.
Случайное рехеширование - попытка поместить объект в строку хэш-таблицы, вычисляемую по формуле: hi(a)=(h0(a)+ri)mod n, где ri - псевдослучайное число.
Тестирование - проверка объекта на несоответствие определенным требованиям.
Принципы тестирования - 1.Описание предполагаемых значений выходных данных или результатов должно быть необходимой частью тестового набора. 2.Тесты для неправильных и непредусмотренных входных данных следует разрабатывать так же тщательно, как для правильных и предусмотренных. 3.Необходимо проверять не только делает ли программа то, для чего она предназначена, но и не делает ли она то, что не должна делать.
Инспекция исходного текста - представляет собой набор процедур и приемов обнаружения ошибок при изучении текста группой специалистов (участникам группы заранее выдается листинг программы и спецификация на нее, программист рассказывает о логике работы программы и отвечает на вопросы инспекторов, программа анализируется по списку вопросов для выявления исторически сложившихся общих ошибок программирования, кому не похуй). 
Сквозной просмотр - представляет собой набор способов обнаружения ошибок, осуществляемых группой лиц, просматривающих текст программы (участникам группы заранее выдают листинг программы и спецификацию на нее, участники мысленно выполняют каждый тест в соответствии с логикой программы, при необходимости программисту задают вопросы о логике проектирования и принятых допущениях).
Проверка «за столом» - проверка исходного текста или сквозные просмотры, выполняемые одним человеком, который читает текст программы, проверяет его на наличие возможных ошибок по специальному списку часто встречающихся ошибок и «пропускает» через программу тестовые данные.
Тестирование как «черного ящика» - тестирование функционального поведения программы с точки зрения внешнего мира (текст программы не используется).
Тестирование как «белого ящика» - тестирование кода на предмет логики работы программы и корректности ее работы с точки зрения компилятора того языка на котором она писалась.
Пошаговое тестирование - тестируем каждый модуль, присоединяя его к уже оттестированным.
Отладка - проверяется правильность работы алгоритма программы, выполняется методом «белого» ящика.
Принципы отладки - делятся на принципы локализации ошибок, т.е. обдумывания и на принципы исправления ошибок.
Метод грубой силы - метод решения задачи путем перебора всех возможных вариантов.
Метод индукции - процесс логического вывода на основе перехода от частного положения к общему.
Метод дедукции - процесс логического вывода на основе перехода от общего положения к частному.
Критерий завершения тестирования - набор условий или активностей, которые должны быть выполнены, чтобы тестирование можно было назвать законченным.
Отладка методом тестирования - выявление ошибок некоторым набором тестов.
Анализ задачи - анализ условия задачи, целью которого является получение недостающей информации.
Обследование задачи - определение исходных данных и результатов.
Постановка задачи(ТЗ) - описание того, что надо сделать, прежде чем писать алгоритм или программу.
Откат - процесс возврата из рекурсивных вызовов (бэктрекинг)
Бэктрекинг - механизм возврата к предыдущему шагу алгоритма с автоматическим восстановлением всех значений, которые были на этом шаге.
Сложность алгоритма по данным - объем ОП, который будет израсходован при расчете этого алгоритма.
Сложность алгоритма по времени вычисления - количество действий, которое будет совершаться алгоритмом.
Управляющий граф алгоритма - вспомогательное средство для оценки сложности алгоритма. 
Оценка сложности “пессимиста” (literally me) - T= Kp + max(KK2)
Средняя оценка сложности - T= Kp + K1*P1 + K2*P2…
Рекурсивная функция сложности рекурсивной процедуры - функция, с помощью которой можно вычислить сложность рекурсивной процедуры, которая основывается на рекуррентном вычислении данных.
Точная оценка сложности - оценка сложности, которую можно определить в виде формулы.
Верхняя оценка сложности - оценка сложности на данных, при которых алгоритм выполняет максимальное количество действий.
Нижняя оценка сложности - оценка сложности, при которой алгоритм выполняет минимальное количество действий.
Задача - формулировка, предоставляемая заказчиком.
Разрешимые задачи - такие задачи, для которых может быть составлен алгоритм решений или можно доказать, что такой алгоритм может существовать.
Неразрешимые задачи - такие задачи, для которых не может быть составлен алгоритм решений.
Общая задача - задача, характерная некоторым набором параметров, но их значения не определяются.
Частная задача - задача на основе общей, но часть или все параметры имеют значения.
Сложность задачи - сложность самого простого (эффективного) алгоритма.
Оптимизация алгоритма - поиск самого простого алгоритма
Задачи полиномиальной сложности - O(x), O(x2), O(x3), …
Задачи экспоненциальной сложности - задачи, для решения которых время работы алгоритма растёт экспоненциально с увеличением размера входных данных.
Класс задач P - O(x), O(x2), O(x3), …
Класс задач EXP - O(nx)
Класс задач NP - задача, которая решается за полиномиальное время при учете того, что используется недетерменированный вычислитель с многопроцессорной архитектурой.
